# -*- coding: utf-8 -*-
"""Genetic Disorder.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XYx-ec2eAlgeoanXNYd5prO7skxhVOc4
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotly.express as px
import seaborn as sns
import pickle

"""# **Importing dataset and splitting it into train and test set**

"""

train_data = pd.read_csv('train.csv')
test_data=pd.read_csv('test.csv')
df_train=train_data.copy()
df_test=test_data.copy()

"""# **Calculating and displaying the percentage of missing values for each feature in training dataset**"""

missing_percentage = (df_train.isnull().sum() / len(df_train)) * 100
print(missing_percentage)

df_train.describe()

"""

# **Counting the occurrences of each class in the target variable 'Genetic Disorder'**"""

df_train['Genetic Disorder'].value_counts()

"""# **Identifying numerical and categorical columns in the training dataset**"""

numerical_cols = df_train.select_dtypes(include=["number"]).columns
categorical_cols = df_train.select_dtypes(include=["object"]).columns

"""# **Heat Map to visualize null vlaues**"""

plt.figure(figsize=(10,6))
sns.heatmap(df_train.isnull(), cbar=False, cmap='viridis')
plt.title('Heatmap of Missing Values')
plt.show()

"""# **Plotting a bar chart to show the count of missing values for each feature in the training dataset**"""

missing_values = df_train.isnull().sum()
missing_values = missing_values[missing_values > 0]

plt.figure(figsize=(12,6))
missing_values.plot(kind='bar', color='red')
plt.title('Missing Values Count by Feature')
plt.xlabel('Count of Missing Values')
plt.show()

"""# **Data Preprocessing**

Deleting NA rows and unimportatn columns
"""

df_train = df_train.dropna(how='all')
columns_to_drop = [
    "Patient Id",
    "Family Name",
    "Institute Name",
    "Patient First Name",
    "Father's name",
    "Location of Institute",
    "Parental consent",
    "Test 1",
    "Test 2",
    "Test 3",
    "Test 4",
    "Test 5",
    "Mother's age",
    "Father's age"
]

df_train = df_train.drop(columns=columns_to_drop, errors='ignore')

"""Mapping genetic disorder with disorder subclass"""

disorder_mapping = {
    "Leber's hereditary optic neuropathy": "Mitochondrial genetic inheritance disorders",
    "Leigh syndrome": "Mitochondrial genetic inheritance disorders",
    "Mitochondrial myopathy": "Mitochondrial genetic inheritance disorders",
    "Alzheimer's": "Multifactorial genetic inheritance disorders",
    "Cancer": "Multifactorial genetic inheritance disorders",
    "Diabetes": "Multifactorial genetic inheritance disorders",
    "Cystic fibrosis": "Single-gene inheritance diseases",
    "Hemochromatosis": "Single-gene inheritance diseases",
    "Tay-Sachs": "Single-gene inheritance diseases",
}

"""Fill Missing 'Genetic Disorder' Based on 'Disorder Subclass'"""

def fill_genetic_disorder(row):
    if pd.isnull(row["Genetic Disorder"]) and row["Disorder Subclass"] in disorder_mapping:
        return disorder_mapping[row["Disorder Subclass"]]
    else:
        return row["Genetic Disorder"]

df_train["Genetic Disorder"] = df_train.apply(fill_genetic_disorder, axis=1)

def fill_missing_values(df_train):
    # Fill missing 'Genetic Disorder' based on 'Disorder Subclass'
    for subclass in df_train['Disorder Subclass'].dropna().unique():
        mode_genetic_disorder = df_train[df_train['Disorder Subclass'] == subclass]['Genetic Disorder'].mode()
        if not mode_genetic_disorder.empty:
            df_train.loc[
                (df_train['Disorder Subclass'] == subclass) & (df_train['Genetic Disorder'].isnull()),
                'Genetic Disorder'
            ] = mode_genetic_disorder[0]

    # Fill missing 'Disorder Subclass' based on 'Genetic Disorder'
    for disorder in df_train['Genetic Disorder'].dropna().unique():
        mode_disorder_subclass = df_train[df_train['Genetic Disorder'] == disorder]['Disorder Subclass'].mode()
        if not mode_disorder_subclass.empty:
            df_train.loc[
                (df_train['Genetic Disorder'] == disorder) & (df_train['Disorder Subclass'].isnull()),
                'Disorder Subclass'
            ] = mode_disorder_subclass[0]

    return df_train

    df_train = fill_missing_values(df_train)

    df_train = df_train.dropna(subset=["Genetic Disorder", "Disorder Subclass"])

"""Dropping rows with missing Genetic Disorder of Disorder Subclass"""

df_train = df_train.dropna(subset=["Genetic Disorder", "Disorder Subclass"])

grouped = df_train.groupby(["Genetic Disorder", "Disorder Subclass"])

def fill_nulls(group):
    for column in group.columns:
        if group[column].isnull().any():
            if group[column].dtype == 'object':
                mode_value = group[column].mode()
                if not mode_value.empty:
                    group[column] = group[column].fillna(mode_value[0])
            else:
                median_value = group[column].median()
                group[column] = group[column].fillna(median_value)
    return group

df_train = grouped.apply(fill_nulls).reset_index(drop=True)

"""Replace missing values in cateforical order"""

missing_values = ["No record", "Not available", "Not applicable", "-", "Ambiguous"]

# Replace specified values with 'Missing' in categorical columns
categorical_cols = df_train.select_dtypes(include='object').columns
for col in categorical_cols:
    df_train[col] = df_train[col].replace(missing_values, 'Missing')

df_train['Symptom Count'] = df_train[['Symptom 1', 'Symptom 2', 'Symptom 3', 'Symptom 4', 'Symptom 5']].sum(axis=1)
df_train.drop(columns=['Symptom 1', 'Symptom 2', 'Symptom 3', 'Symptom 4', 'Symptom 5'], inplace=True)

df_train['Total Blood Cell Count'] = df_train['Blood cell count (mcL)'] + df_train['White Blood cell count (thousand per microliter)']
df_train.drop(columns=['Blood cell count (mcL)', 'White Blood cell count (thousand per microliter)'], inplace=True)

df_train['Combined_disorder']=df_train.apply(lambda row: f"{row['Genetic Disorder'].replace(' ', '_')}_"f"{row['Disorder Subclass'].replace(' ', '_')}",
axis=1)

numerical_cols = df_train.select_dtypes(include=["number"]).columns
categorical_cols = df_train.select_dtypes(include=["object"]).columns
from sklearn.preprocessing import LabelEncoder
label_encoder = LabelEncoder()
for col in categorical_cols:
    df_train[col] = label_encoder.fit_transform(df_train[col])

df_train

"""# **Data Modelling and TESTING**"""

from sklearn.model_selection import train_test_split

X =df_train.drop(columns=['Genetic Disorder'])
Y = df_train[['Genetic Disorder']]

x_train  , x_test , y_train, y_test = train_test_split (X ,Y ,test_size = 0.2 , random_state = 42)

from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.naive_bayes import GaussianNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
from sklearn.preprocessing import RobustScaler, MinMaxScaler, StandardScaler
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

# Define the classifiers dictionary

classifiers = {

    'Logistic Regression': LogisticRegression(),

    'SVM': SVC(),

    'Naive Bayes': GaussianNB(),

    'KNN': KNeighborsClassifier(),

    'Decision Tree': DecisionTreeClassifier(),

    'Random Forest': RandomForestClassifier()

}

best_models = {}
accuracy_results = []

for classifier_name, classifier in classifiers.items():
    best_accuracy = 0
    best_scaler_name = None
    best_y_pred = None
    best_model = None

    scaler = StandardScaler()

    x_train_scaled = scaler.fit_transform(x_train)
    x_test_scaled = scaler.transform(x_test)

    classifier.fit(x_train_scaled, y_train)
    y_pred = classifier.predict(x_test_scaled)

    train_accuracy = accuracy_score(y_train, classifier.predict(x_train_scaled))
    test_accuracy = accuracy_score(y_test, y_pred)

    print(f'Using StandardScaler with {classifier_name}:')
    print(f'Train Accuracy: {train_accuracy:.4f}')
    print(f'Test Accuracy: {test_accuracy:.4f}')
    print('-' * 40)

    if test_accuracy > best_accuracy:
        best_accuracy = test_accuracy
        best_scaler_name = 'StandardScaler'
        best_y_pred = y_pred
        best_model = classifier

    best_models[classifier_name] = (best_model, best_scaler_name)

    print(f'Confusion Matrix for {classifier_name} using StandardScaler:')
    cm = confusion_matrix(y_test, best_y_pred)
    fig, ax = plt.subplots(figsize=(10, 5))
    sns.heatmap(cm, annot=True, cmap="YlGnBu", fmt='g')
    plt.title(f'Confusion matrix for {classifier_name}', y=1.1)
    ax.xaxis.set_label_position("top")
    plt.tight_layout()
    plt.xlabel('y prediction')
    plt.ylabel('y actual')
    plt.show()

    print(f'Classification Report for {classifier_name} using StandardScaler:')
    report = classification_report(y_test, best_y_pred)
    print(report)

    accuracy_results.append({
        'Model': classifier_name,
        'Scaler': 'StandardScaler',
        'Train Accuracy': train_accuracy,
        'Test Accuracy': best_accuracy
    })

accuracy_df = pd.DataFrame(accuracy_results)
display(accuracy_df)